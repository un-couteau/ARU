.. ARU (c) 2018 - 2022, Pavel Priluckiy, Vasiliy Stelmachenok and contributors

   ARU is licensed under a
   Creative Commons Attribution-ShareAlike 4.0 International License.

   You should have received a copy of the license along with this
   work. If not, see <https://creativecommons.org/licenses/by-sa/4.0/>.

.. _generic-system-acceleration:

***************************
Базовое ускорение системы
***************************

Переходя к базовой оптимизации системы мне сто́ит напомнить, что чистый
Arch Linux - это фундамент, и требуется уйма надстроек для нормальной
работы системы. Установить компоненты, которые будут отвечать за
электропитание, чистку, оптимизацию и тому подобные вещи, что и
описывается в данном разделе.

.. index:: makepkg-conf, native-compilation, flags, lto
.. _makepkg-conf:

======================
Настройка makepkg.conf
======================

Прежде чем приступать к сборке пакетов, мы должны изменить так
называемые флаги компиляции, что являются указателями для компилятора,
какие инструкции и оптимизации использовать при сборке программ.

``sudo nano /etc/makepkg.conf`` # Редактируем (Где "-O2" - **Это не нуль/ноль**)

**Изменить ваши значения на данные:** ::

  CFLAGS="-march=native -mtune=native -O2 -pipe -fno-plt -fexceptions \
        -Wp,-D_FORTIFY_SOURCE=2 -Wformat -Werror=format-security \
        -fstack-clash-protection -fcf-protection"
  CXXFLAGS="$CFLAGS -Wp,-D_GLIBCXX_ASSERTIONS"
  RUSTFLAGS="-C opt-level=3"
  MAKEFLAGS="-j$(nproc) -l$(nproc)"
  OPTIONS=(strip docs !libtool !staticlibs emptydirs zipman purge !debug lto)

Данные флаги компилятора выжимают максимум производительности при
компиляции, но могут вызывать ошибки сборки в очень редких
приложениях. Если такое случится, то отключите параметр ‘lto’ в строке
options добавив перед ним символ восклицательного знака  ! (*"!lto"*).

.. index:: makepkg, ccache, native-compilation
.. _enabling_ccache:

-----------------------
Включение ccache
-----------------------

В Linux системах есть не так много программ, сборка которых может
занять больше двух часов, но они все таки есть. Потому, было бы
неплохо ускорить повторную компиляцию таких программ как
Wine/Proton-GE и т.д.

ccache - это кэш для компиляторов C/C++, в частности совместимый с
компиляторами GCC/Clang, цель которого состоит в ускорении повторного
процесса компиляции одного и того же кода. Это значит, что если при
сборке программы новой версии, будут замечены полностью идентичные
блоки исходного кода в сравнении с его старой версией, то компиляция
этих исходных текстов производиться не будет. Вместо этого, уже
готовый, скомпилированный код старой версии будет вынут из кэша
ccache. За счёт этого и достигается многократное ускорение процесса
компиляции.

**Установка** ::

  sudo pacman -S ccache

После установки его ещё нужно активировать в ваших настройках makepkg.
Для этого отредактируем конфигурационный файл::

  sudo nano /etc/makepkg.conf

  # Найдите данную строку в собственных настройках, затем уберите восклицательный знак перед *"ccache"*
  BUILDENV=(!distcc color ccache check !sign)

После этого повторная пересборка желаемых программ и их обновление
должны значительно ускориться.

.. attention:: ccache может ломать сборку некоторых программ, поэтому будьте внимательны с его применением.

.. index:: installation, ananicy, zram, nohang, rng-tools, haveged, trim, dbus-broker
.. _daemons-and-services:

======================================
Установка полезных служб и демонов
======================================

**1.** `Zramswap <https://aur.archlinux.org/packages/zramswap/>`_ —
это специальный демон, который сжимает оперативную память ресурсами
центрального процессора и создает в ней файл подкачки. Очень ускоряет
систему вне зависимости от количества памяти, однако добавляет
нагрузку на процессор, т.к. его ресурсами и происходит сжатие памяти.
Поэтому, на слабых компьютерах с малым количеством ОЗУ, это может
негативно повлиять на производительность в целом. ::

  git clone https://aur.archlinux.org/zramswap.git  # Скачивание исходников.
  cd zramswap                                       # Переход в zramswap.
  makepkg -sric                                     # Сборка и установка.
  sudo systemctl enable --now zramswap.service      # Включаем службу.

Чтобы немного ускорить работу zram рекомендуется также изменить
алгоритм сжатия памяти::

  echo "ZRAM_COMPRESSION_ALGO=zstd" | sudo tee -a /etc/zramswap.conf

.. warning:: Во избежание конфликтов, после установки zram обязательно
   отключите zswap через добавление параметра ядра ``zswap.enabled=0``.

**1.1** `Nohang <https://github.com/hakavlad/nohang>`_  — это демон
повышающий производительность путём обработки и слежки за потреблением
памяти. ::

  git clone https://aur.archlinux.org/nohang-git.git # Скачивание исходников.
  cd nohang-git                                      # Переход в nohang-git
  makepkg -sric                                      # Сборка и установка.
  sudo systemctl enable --now nohang-desktop         # Включаем службу.

**1.2** `Ananicy CPP <https://gitlab.com/ananicy-cpp/ananicy-cpp>`_ —
это форк одноименного демона, распределяющий приоритет задач. Его
установка очень сильно повышает отклик системы. В отличии от
оригинального Ananicy, данный форк переписан полностью на C++, из-за
чего достигается прирост в скорости работы. ::

  git clone https://aur.archlinux.org/ananicy-cpp.git # Скачивание исходников.
  cd ananicy-cpp                                      # Переход в ananicy-cpp.
  makepkg -sric                                       # Сборка и установка.
  sudo systemctl enable --now ananicy-cpp             # Включаем службу.
  
  # Далее описывается установка дополнительных правил по перераспределению приоритетов процессов
  git clone https://aur.archlinux.org/ananicy-rules.git # Скачивание исходников
  cd ananicy-rules                                      # Переход в директорию
  makepkg -sric                                         # Сборка и установка
  sudo systemctl restart ananicy-cpp                    # Перезапускаем службу

**1.3** Включаем `TRIM
<https://ru.wikipedia.org/wiki/Trim_(команда_для_накопителей)>`_ —
очень полезно для SSD. ::

  sudo systemctl enable fstrim.timer    # Включаем службу.
  sudo fstrim -v /                      # Ручной метод.
  sudo fstrim -va /                     # Если первый метод не тримит весь диск.

**1.4** `Сron <https://wiki.archlinux.org/title/cron>`_ — это демон,
который поможет вам очищать вашу систему от мусора полностью
автономно. ::

  sudo pacman -S cronie                         # Установить cron.
  sudo systemctl enable --now cronie.service    # Запускает и включает службу.
  sudo EDITOR=nano crontab -e                   # Редактируем параметр.

И прописываем:

*15 10 * * sun /sbin/pacman -Scc --noconfirm*

Таким образом наша система будет чистить свой кэш раз в неделю, в
воскресенье в 15:10.

**1.5** `haveged
<https://wiki.archlinux.org/title/Haveged_(Русский)>`_ - это демон,
что следит за энтропией системы. Необходим для ускорения запуска
системы при высоких показателях в: *systemd-analyze blame* (Больше 1
секунды). ::

  sudo pacman -S haveged        # Установка
  sudo systemctl enable haveged # Включает и запускает службу.

.. warning:: Используйте только на LTS ядрах 4.19 и 5.4. На новых
   ядрах необходимости в использовании нет.

**1.5.1** `rng-tools <https://wiki.archlinux.org/title/Rng-tools>`_ -
демон, что также следит за энтропией системы, но в отличие от haveged
уже через аппаратный таймер. Необходим для ускорения запуска системы
при высоких показателях *systemd-analyze blame* (Больше 1 секунды). ::

  sudo pacman -S rng-tools         # Установка
  sudo systemctl enable --now rngd # Включает и запускает службу.

**1.6** `dbus-broker <https://github.com/bus1/dbus-broker>`_ - Это
реализация шины сообщений в соответствии со спецификацией D-Bus. Её
цель - обеспечить высокую производительность и надежность при
сохранении совместимости с эталонной реализацией D-Bus. Обеспечивает
чуть более быстрое общение с видеокартой через PCIe. ::

  sudo pacman -S dbus-broker                         # Уставновка
  sudo systemctl enable --now dbus-broker.service    # Включает и запускает службу.
  sudo systemctl --global enable dbus-broker.service # Включает и запускает службу для всех пользователей.

Если у вас ещё возникает вопрос: "Что действительно нужно установить
из вышеперечисленного?", то просто посмотрите на следующую схему:

.. image:: images/generic-system-acceleration-1.png

**1.7** `irqbalance <https://github.com/Irqbalance/irqbalance>`_ - это
это демон, что автоматически балансирует обработку прерываний
по ядрам процессора. ::

  sudo pacman -S irqbalance
  sudo systemctl enable --now irqbalance

.. index:: swap, swappiness, sysctl
.. _swap:

==================
Настойка подкачки
==================

По умолчанию Linux достаточно чрезмерно использует подкачку,
что не всегда хорошо сказывается на домашних системах, а точнее
на их отклике.

Параметр ``vm.swappiness`` определяет то, насколько аггрессивно
страницы оперативной памяти (в Linux вся память представлена в виде
маленьких "гранул" - страниц памяти, как правило 4 КБ) будут
вытесняться в подкачку. То есть, чем выше значение этого параметра,
тем более аггрессивно ядро будет использовать подкачку, и как
следствие экономить физическую оперативную память. На первый взгляд
все нормально, но значением по умолчанию является ``60``, что
достаточно много для систем которые обаладают 8 Гб и более. Нам же
нужно понизить данное значение для повышения отклика (в некоторых
случаях требуется обратное действее, т.е. аггрессивное использование
подкачки, об этом далее). Смысл здесь в следующем: страницы памяти,
занимаемые определенным процессом, могут долгое время не
использоваться, из-за чего ядро, как раз в зависимости от параметра
``vm.swappiness``, будет считать что эти страницы могут быть
вытеснены в подкачку (файл/раздел), однако в случае если эти страницы
станут снова нужны, то процесс их обратного возврата в оперативную
память будет занимать какое-то время (ибо как известно любой
раздел/файл подкачки на диске работает медленее ОЗУ), и это будет
выглядить как замедленее работы приложения. Поэтому рекомендуется
установить значение ``10``::

  sudo nano /etc/sysctl.d/99-sysctl.conf # Редактируем

  vm.swappiness=10

Это приведет к большему количеству страницы висящих в памяти без дела,
в то же время как только эти страницы станут снова нужны они смогут
быстро вернуться в строй без задержек. Подобный эффект можно будет
наглядно увидеть на примере переключения между различными программами.
Если страницы неиспользуемых приложений не будут вытеснены в подкачку,
то переключение между ними может быть осуществлено без каких-либо
замедлений.

Тем не менее, в системах, обладающих малым объемом ОЗУ (4 гб и менее),
установка столь низкого значения может привести к проблеме нехватки
памяти, поэтому в этом случае рекомендуется наоборот указывать более
высокие значения.

В то же время, в случае если в предыдущем разделе вы включили
использование zramswap, то рекомендуемым значением уже будет ``100``.
Т.к. zramswap подразуемвает подкачку непосредственно в памяти, с
предварительным сжатием, то установка ``100`` позволяет оставлять все
неиспользуемые страницы в ОЗУ, но только в сжатом виде, что тоже даёт
экономию памяти, при этом процесс их распаковки будет в разы быстрее
чем процесс загрузки страниц обратно в память из подкачки на диске. Но
стоит учитывать, что процесс сжатия/расжатия страниц даёт
дополнительную нагрузку на процессор.

В качестве дополнительной оптимизации zramswap можно выделить
параметр ``vm.page-cluster=0``. Он отвечает за то, 
сколько страниц будут одновременно прочитаны из раздела подкачки.
Значение по умолчанию ``3`` больше рассчитано на жёсткие диски,
чем на SSD или zram. Значение ``1`` увеличивает пропусную способность
на 22% по сравнению с ``0``, однако увеличивает задержки на 55% в
случае с алгоритмом сжатия lz4. Обсуждение и бенчмарки `тут
<https://www.reddit.com/r/Fedora/comments/mzun99/new_zram_tuning_benchmarks/>`_.

.. warning:: Автор настоятельно не рекомендует устанавливать значение
   параметра в 0 (отключать подкачку вовсе). Подробнее о том, почему
   это вредно читайте в данной статье -
   https://habr.com/ru/company/flant/blog/348324/. Если вы хотите
   минимизировать использование подкачки, то просто установите
   значение 1 или 5. А лучше - используйте уже упомянутый zramswap.

.. index:: lowlatency, audio, pusleaudio
.. _lowlatency-audio:

=============================
Низкие задержки звука
=============================

Установите следующие пакеты для понижения задержек звука в PulseAudio,
а также удобную графическую панель управления звуком -  *pavucontrol*.

::

  sudo pacman -S pulseaudio pulseaudio-alsa pulseaudio-jack pavucontrol

.. index:: installation, lowlatency, audio, pipewire
.. _pipewire-installation:

------------------------------
Новая альтернатива PulseAudio
------------------------------

`PipeWire <https://wiki.archlinux.org/title/PipeWire_(Русский)>`_ -
это новая альтернатива PulseAudio, которая призвана избавить от
проблем PulseAudio, уменьшить задержки звука и потребление памяти. ::

  sudo pacman -S pipewire pipewire-alsa pipewire-pulse pipewire-jack
  systemctl --user enable --now pipewire.service pipewire.socket pipewire-pulse.service wireplumber.service

Дополнительно советуем установить реализацию Jack API. См. раздел
ниже.

-----------------
Реализации JACK
-----------------

Существует три различных реализации JACK API: просто jack из AUR,
jack2 и pipewire-jack. Наглядное сравнение их возможностей показано
таблицей ниже:

.. image:: images/jack-implementations.png

Установите один из вышеуказанных пакетов. Для поддержки 32-битных
приложений также установите пакет lib32-jack из AUR, lib32-jack2 или
lib32-pipewire-jack (соответственно) из репозитория multilib.

Для официальных примеров клиентов и инструментов JACK установите
`jack-example-tools
<https://archlinux.org/packages/extra/x86_64/jack-example-tools/>`_.

Для альтернативной поддержки ALSA MIDI в jack2 установите `a2jmidid.
<https://archlinux.org/packages/community/x86_64/a2jmidid/>`_.

Для поддержки dbus с jack2 установите `jack2-dbus
<https://archlinux.org/packages/extra/x86_64/jack2-dbus/>`_
(рекомендуется).

`realtime-privileges <https://archlinux.org/packages/community/any/realtime-privileges/>`_
- для понижения задержек звука (актуально как для JACK, так и для PipeWire)

.. index:: lowlatency, audio, alsa
.. _alsa:

-------------
Простая ALSA
-------------

ALSA - это тот самый звук (условно, на самом деле это звуковая
подсистема ядра), который идёт напрямую из ядра и является самым
быстрым, так как не вынужден проходить множество программных прослоек
и микширование. ::

  sudo pacman -S alsa alsa-utils alsa-firmware alsa-card-profiles alsa-plugins

Поэтому, если у вас нет потребности в микшировании каналов, записи
аудио через микрофон и вы не слушаете музыку через Bluetooth, то ALSA
может вам подойти.Пакет *alsa-utils* также содержит консольный Микшер
(настройка громкости), который вызывается командой alsamixer.

Вообще, выбор звукового сервера не такая уж сложная задача как вам
может показаться, достаточно взглянуть на следующую схему:

.. image:: images/generic-system-acceleration-2.png

.. index:: startup-acceleration, networkmanager, service, 
.. _startup-acceleration:

===================================================================
Ускорение загрузки системы (Отключение NetworkManager-wait-online)
===================================================================

В большинстве случаев для настройки интернет подключения вы, скорее
всего, будете использовать NetworkManager, т.к. он является в этом
деле швейцарским ножом и поставляется по умолчанию. Однако, если вы
пропишите команду *systemd-analyze blame*, то узнаете, что он
задерживает загрузку системы примерно на ~4 секунды. Чтобы это
исправить выполните::

  sudo systemctl mask NetworkManager-wait-online.service

.. index:: startup-acceleration, hdd, lz4, mkinitcpio
.. _speed-up-hdd-startup:

------------------------------------------------------------------------
Ускорение загрузки ядра на HDD накопителях (*Только для жестких дисков*)
------------------------------------------------------------------------

Убедитесь, что пакет `lz4
<https://archlinux.org/packages/core/x86_64/lz4/>`_ установлен::

  sudo pacman -S lz4

Отредактируйте файл:::

  sudo nano /etc/mkinitcpio.conf

Теперь выполните следующие действия:

-  Добавьте *lz4 lz4_compress* в массив *MODULES* (ограничен скобками)
-  Раскомментируйте или добавьте строку с надписью *COMPRESSION="lz4"*
-  Добавьте строку если её нет -  *COMPRESSION_OPTIONS="-9"*
-  Добавите *shutdown* в массив *HOOKS* (ограничен скобками)

Это ускорит загрузку системы на слабых жёстких дисках благодаря более
подходящему методу сжатия образов ядра.

.. index:: startup-acceleration, hdd, ssd, systemd, mkinitcpio
.. _speed-up-systemd-startup:

-----------------------------------------
Ускорение загрузки ядра c помощью systemd
-----------------------------------------

Есть ещё способ ускорить загрузку системы, используя систему инициализации systemd
Для этого нужно убрать ``base`` и ``udev`` из массива HOOKS, и заменить их
на ``systemd`` что бы он выглядел примерно так::

  HOOKS=(systemd autodetect modconf block filesystems keyboard)

Это немного увеличит образ initramfs, но заметно может ускорить запуск системы.

======================
Твики драйверов Mesa
======================

.. index:: amd, sam, bar
.. _force_amd_sam:

--------------------------------------------------------------------------
Форсирование использования AMD SAM *(Только для опытных пользователей)*.
--------------------------------------------------------------------------

AMD Smart Acess Memory (или Resizble Bar) — это технология которая
позволяет процессору получить доступ сразу ко всей видеопамяти GPU, а
не по отдельности для каждого распаянного чипа создавая задержки.
Несмотря на то, что данная технология заявлена только для оборудования
AMD и требует новейших комплектующих для обеспечения своей работы, мы
активируем технологию для видеокарты 10 летней давновсти ATI Radeon HD
7770 и сравним буст производительности в паре игр.

.. danger:: Для включения данной технологии в настройках вашего BIOS
   (UEFI) должна быть включена опция *"Re-Size BAR Support"* и *"Above
   4G Decoding"*. Если таких параметров в вашем BIOS (UEFI) нет -
   скорее всего технология не поддерживается вашей материнской платой
   и не стоит даже пытаться её включить.

Чтобы активировать SAM в Linux нужно отредактировать конфигурацию DRI,
дописав в конфиг следующие строки::

  nano ~/.drirc # Редактируем конфигурационный файл

  # Прописать строки ниже

  <?xml version="1.0" standalone="yes"?>
  <driconf>
    <device>
      <application name="Default">
        <option name="radeonsi_enable_sam" value="true" />
      </application>
    </device>
  </driconf>

Альтернативно её можно активировать через глобальные переменные окружения::

  sudo nano /etc/environment # Редактируем конфигурационный файл

  # Добавить следующие строки
  radeonsi_enable_sam=true
  # Если используете драйвер RADV
  RADV_PERFTEST=sam

Проверить работу технологии можно через команду::

  AMD_DEBUG=info glxinfo | grep smart # Должно быть smart_access_memory = 1

**Пример тестирования технологии на видеокарте старого поколения
(Windows)**

https://youtu.be/tZmPi9tfLbc

.. index:: amd, tweaks
.. _bug_solution_for_vega:

-------------------------------------------------------------------
Решение проблем работы графики Vega 11 (Спасибо @Vochatrak-az-ezm)
-------------------------------------------------------------------

На оборудовании со встроенным видеоядром Vega 11 может встретиться баг
драйвера, при котором возникают случайные зависания графики. Проблема
наиболее актуальна для *Ryzen 2XXXG* и чуть реже встречается на Ryzen
серии *3XXXG*, но потенциально имеет место быть и на более новых
видеоядрах Vega.

Решается через добавление следующих параметров ядра::

  # Редактируем конфигурационный файл в зависимости от того, какой у вас загрузчик
  sudo nano /etc/default/grub

  # Параметры можно дописать к уже имеющимся
  GRUB_CMDLINE_LINUX_DEFAULT="mdgpu.gttsize=8192 amdgpu.lockup_timeout=1000 amdgpu.gpu_recovery=1 amdgpu.noretry=0 amdgpu.ppfeaturemask=0xfffd3fff amdgpu.deep_color=1 systemd.unified_cgroup_hierarchy=true"

На всякий случай можно дописать ещё одну переменную окружения::

  # Прописать строчку ниже
  sudo nano /etc/enviroment

  AMD_DEBUG=nodcc

Для подробностей можете ознакомиться со следующими темами:

https://www.linux.org.ru/forum/linux-hardware/16312119

https://www.linux.org.ru/forum/desktop/16257286

.. index:: intel, amd, mesa, tweaks
.. _multithreaded_opengl:

--------------------------------
Многопоточная OpenGL обработка
--------------------------------

У Mesa есть свой аналог переменной окружения
``__GL_THREADED_OPTIMIZATIONS=1``, так же предназначенный для
активирования многопоточной обработки OpenGL - ``mesa_glthread=true``.
В ряде игр и приложений это даёт сильное увеличение
производительности, но в некоторых либо нет прироста, либо вовсе не
может быть применено.

Чтобы включить его для всей системы нужно либо прописать переменную
окружения в файл ``/etc/environment``, либо используя adriconf_,
включив параметр во вкладке *"Performance"* -> *"Enable offloading GL
driver work to a separate thread"*

.. _adriconf: https://archlinux.org/packages/community/x86_64/adriconf/

.. vim:set textwidth=70:
